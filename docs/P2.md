---
toc: true
sql:
    spotify: ./data/spotify-2023-artistas.csv
---

<style>
    body, div, p, li, ol { max-width: none; }
</style>

# Pergunta 2
O conjunto das top 10 músicas e dos top 10 artistas varia muito se considerarmos apenas musicas lançadas no mesmo ano?

## Interação


```js
const spotifyData = await FileAttachment("./data/spotify-2023-artistas.csv").csv({typed: true});

// Obter os anos mínimo e máximo do conjunto de dados
const years = spotifyData.map(d => d['released_year']);
const maxYear = Math.max(...years);
```

```js
// Criar o slider com base nos anos mínimo e máximo e com interações especificadas
const yearSlider = view(Inputs.range([1930, maxYear], {value: 1930, step: 1, label: "Years"}));

```

## Visualizações

<div class="grid grid-cols-2">
    <div id="ex01" class="card grid-colspan-2" >
        <h2 class="title">Top 10 músicas mais tocadas</h2>
        <div style="width: 100%; margin-top: 15px;">
            ${ vl.render(ex01(divWidth - 100)) }
        </div>
    </div>
    <div id="ex02" class="card grid-colspan-2">
        <h2>Top 10 artistas mais ouvidos</h2>
        <div style="width: 100%; margin-top: 15px;">
            ${ vl.render(ex02(divWidth - 100)) }
        </div>
    </div>
</div>

<!--Tamanho dos cards. Caso vcs usem cards de multiplos tamanhos, 
    será necessário criar um generator para cada classe de card.
-->
```js
const divWidth = Generators.width(document.querySelector("#ex01"));

```

```js
const gapSubset = spotifyData.filter(d => d['released_year'] === yearSlider);
```

```js
function processData(data) {
    const groupedData = data.reduce((acc, curr) => {
        const key = `${curr.artists}-${curr.released_year}`;
        const streams = parseInt(String(curr.streams).replace(/,/g, ''));
        
        if (!acc[key]) {
            acc[key] = {
                artists: curr.artists,
                streams: streams,
                released_year: curr.released_year
            };
        } else {
            acc[key].streams += streams;
        }
        return acc;
    }, {});

    return Object.values(groupedData);
}
```
```js
function processData2(data) {
    const groupedData = data.reduce((acc, curr) => {
        const key = `${curr.track_name}-${curr.released_year}`;
        const streams = parseInt(String(curr.streams).replace(/,/g, ''));

        if (!acc[key]) {
            acc[key] = {
                track_name: curr.track_name,
                streams: streams,
                released_year: curr.released_year
            };
        } else {
            acc[key].streams += streams;
        }
        return acc;
    }, {});

    return Object.values(groupedData);
}
```

```js
import * as vega from "npm:vega";
import * as vegaLite from "npm:vega-lite";
import * as vegaLiteApi from "npm:vega-lite-api";

const vl = vegaLiteApi.register(vega, vegaLite);

function ex01(divWidth) {
    const processedData = processData2(gapSubset);

    const sortedArtists = processedData.sort((a, b) => b.streams - a.streams);

    const topArtists = sortedArtists.slice(0, 10);

    return {
        spec: {
            width: divWidth,
            height: 400,
            data: {
                values: topArtists,
            },
            mark: {
                type: "bar",
                tooltip: true,
            },
            encoding: {
                x: {
                    field: "track_name",
                    type: "nominal",
                    sort: "-y",
                },
                y: {
                    field: "streams",
                    type: "quantitative",
                }
            }
        }
    }
}

function ex02(divWidth) {
    const processedData = processData(gapSubset);

    const sortedArtists = processedData.sort((a, b) => b.streams - a.streams);

    const topArtists = sortedArtists.slice(0, 10);

    return {
        spec: {
            width: divWidth,
            height: 400,
            data: {
                values: topArtists,
            },
            mark: {
                type: "bar",
                tooltip: true,
            },
            encoding: {
                x: {
                    field: "artists",
                    type: "nominal",
                    sort: "-y",
                },
                y: {
                    field: "streams",
                    type: "quantitative",
                }
            }
        }
    }
}
```


## Análise
1. Analisando os dados exibidos acima e utilizando o controle deslizante de data, nota-se que, com o passar dos anos, alguns artistas permanecem no top 10, enquanto, por outro lado, dificilmente uma música consegue se manter relevante de um ano para o outro.

2. Um exemplo disso pode ser observado entre os anos de 2018 até 2020 pelo artista The Weeknd. Mesmo ficando no top 10 três anos seguidos, cada ano foi por uma música diferente: Call Out My Name (2018), Blinding Lights	(2019)	e Save Your Tears (2020).

## Design utilizados
1. Os canais visuais empregados nas visualizações permitem a análise detalhada das top 10 músicas e dos top 10 artistas em um determinado ano. Usando gráficos de barras, é possível comparar diretamente a popularidade das músicas e dos artistas com base no número de streams, enquanto a interatividade do controle deslizante permite a exploração de diferentes anos, fornecendo insights sobre como a popularidade varia ao longo do tempo. Detalhando os canais visuais, utilizamos marcação (barras) - nome do artista no eixo X, quantidade de streams no eixo Y, e também utilizamos um tooltip para exibir informações detalhadas ao passar o cursor.